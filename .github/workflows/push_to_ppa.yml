# This is a basic workflow to help you get started with Actions
---
name: push to PPA

on:
  push:
    tags:
      - 'v*'
      - 'debianlike/*-[2-9]'
      - 'debianlike/*-[1-9][0-9]+'
      - '!debianlike/*-1'
      - '!**-alpha**'    # ignore -alpha tags
      - '!**-pre**'      # ignore -pre tags
  schedule:
    - cron: 10 9 * * 0-6
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: set env
        run: |
          set -x
          export      debian_branch="debianlike"       # branch debian/ lives on
          export   debian_changelog="debian/changelog" # no need to change
          export upstream_user_repo="dosbox-staging/dosbox-staging"

          export        DEBFULLNAME="builddebtest"       # These will be used in
          export           DEBEMAIL="blddebtest@foo.com" # commit, changelog

          export             PPA_ID="feignint/dosbox-staging" # PPA to push to

          export GPG_TTY="$(tty)"
          printf "::set-env name=%s::%s\n" "GPG_TTY" "${GPG_TTY}"
          # import private gpg key used to sign, this must match the gpg key
          # registered with the PPA being pushed to.

          # support both "ASCII armoured" and straight base64
          if [[ ${PPA_GPG_SSB_PK:0:10} == "-----BEGIN" ]]
          then
            # gpg --armor --export-secret-subkeys <ID>
            gpg --batch --import <<<"$PPA_GPG_SSB_PK" || exit 101
          else
            # no ascii armor wrapper, so assume base64 encoded
            # e.g. gpg --export-secret-subkeys | base64
            gpg --batch --import < <(
               base64 --decode <<<"$PPA_GPG_SSB_PK" ) || exit 101
          fi

          Get_tags_json()
          {
            curl -s "${GITHUB_API_URL}/repos/$1/tags"
            #TODO make more robust, i.e. loop a bit if timeout
          }
          filter()
          {
            # was nice to see jq installed by default, so put it to use
            # build an ERE pattern to filter already done tags out
            jq -j '.[]|
              select(.name|test("'${debian_branch}'/"))|
                .name|
                sub("'${debian_branch}'/";"^v")|
                sub("-[0-9]+$";"")|
                sub("_";"-"), "$|"' < <(
                  Get_tags_json "${GITHUB_REPOSITORY}" )
          }
          SetTAG()
          {
            readarray -t -O 0 upstreamTAGs < <(
              jq -j '.[]|
                select(.name |
                 test("^v")) |
                select(.name |
                 test("'"$( filter )"'^v.+-alpha$|^v.+-pre$") | not ) |
                 .name,"|",.commit.sha, "\n"' < <(
                   Get_tags_json "${upstream_user_repo:=${GITHUB_REPOSITORY}}" )
            )
            [[ ${#upstreamTAGs[@]} -gt 0 ]] ||
              exit 0 # no new tags, exit gracefully

            TAG="${upstreamTAGs[-1]%|*}" &&
              upstreamCommit="${upstreamTAGs[-1]#*|}"
            #TODO use upstreamCommit, or lose it...
            #  I was going to use the sha to fetch the commit
            #  but gbp will do that just fine on its own

          }

          [[ ${GITHUB_EVENT_NAME} == schedule ]] && SetTAG

          export              TAG="${TAG:=${GITHUB_REF#refs/tags/}}"
          export      upstreamTAG="${TAG}"
          # upstreamTAG might be debTAG !
          # however, it really does not matter, upstreamTAG is only used
          # to determine if a releasenotes link is to be added to changelog
          # if we are processing a debTAG, the changelog already exists
          # TODO remove upstreamTAG, it was just a hangover from shell script

          export   upstreamPrefix="${TAG%%[0-9][.]*}"

          # account for debian versioned tags
          [[ $upstreamPrefix == ${debian_branch}/ ]] &&
          [[ ${TAG##*-} =~ ^([2-9]|[1-9][0-9]+)$  ]] &&
                             debSUFFIX="-${TAG##*-}" || debSUFFIX="-1"
          # i.e. if it looks like a debTAG preserve Suffix,
          # else reset to -1 ( debTAG will be created )

                       debVersion="${TAG%${debSUFFIX}}"
                       debVersion="${debVersion/-/\~}"
                       debVersion="${debVersion#${upstreamPrefix}}"
                           debTAG="${debian_branch}/${debVersion/\~/_}"

          export       debVersion="${debVersion/_/\~}${debSUFFIX}"
          export           debTAG="${debTAG}${debSUFFIX}"

          for envvar in                    \
                        debian_branch      \
                        debian_changelog   \
                        upstream_user_repo \
                        DEBFULLNAME        \
                        DEBEMAIL           \
                        PPA_ID             \
                        TAG                \
                        upstreamTAG        \
                        upstreamPrefix     \
                        debVersion         \
                        debTAG             \
          ;do
            declare -n envvar_nameref="$envvar"
            printf "::set-env name=%s::%s\n"  \
                    "${envvar}"               \
                    "${envvar_nameref}"
          done
        env:
          PPA_GPG_SSB_PK: ${{ secrets.PPA_GPG_SSB_PK }}
      - name: install depends
        if: ${{ env.TAG != '' }}
        run: |
          set -x
          sudo apt-get update # upgrade takes ages
          sudo apt-get install -y --install-recommends=no \
            git-buildpackage dput debhelper lintian
          # lintian not strictly needed, but will make the tail end of github's
          # log a little more verbose.

      - name: Checkout dosbox-staging
        if: ${{ env.TAG != '' }}
        uses: actions/checkout@v2
        with:
          fetch-depth: 1
          ref: ${{ env.debian_branch }}
      - name: sanity check
        if: ${{ env.TAG != '' }}
        run: |
          set -x
          git config --local user.name  "$DEBFULLNAME"
          git config --local user.email "$DEBEMAIL"
          git fetch --prune --unshallow --tags --force

          # if we are not the upstream dosbox-staging, remote add it
          if [[ ${GITHUB_REPOSITORY} != ${upstream_user_repo} ]]
          then
            git remote add upstream https://github.com/${upstream_user_repo}.git
            git fetch --prune --tags --force upstream
          fi
          # before continuing be certain TAG exists ( should never not exist )
          # TODO if I'm going to use upstreamCommit use in fetch
          [[ $( git tag --list "${TAG}" ) == "${TAG}" ]] || exit 2
      - name: Changelog
        if: ${{ env.TAG != '' }}
        run: |
          set -x
          append_changelog()
          {

            # create snapshot
            gbp dch --new-version="${debVersion}"  \
                    --snapshot                     \
                    --spawn-editor=never           \
                    -- debian/ || exit 6
            # tweak it
            PostEdit_Changelog
            # commit it
            gbp dch --release                      \
                    --spawn-editor=never           \
                    --commit || exit 7
          }

          Changelog_template()
          {
            # might have something useful in the tag annotation
            TagAnnotation="$(
              grep -E "^[^tag]{3}.+[0-9][.][0-9]{2}[.][0-9]"       \
                < <( git tag --verify "${upstreamTAG}" 2>/dev/null )
            )"
            Changelog=( "* ${TagAnnotation:-New Upstream Release:}\n" )

            # only include release notes link if it exists
            ReleaseNotesTAG="v${upstreamTAG#${upstreamPrefix}}" # note v prefix
            ReleaseNotesURL="https://dosbox-staging.github.io/${ReleaseNotesTAG//[.]/-}/"

            < <(curl -s --compressed "${ReleaseNotesURL}" ) \
              grep -m1 "404: Page not found" ||
                Changelog+=( "- ${ReleaseNotesURL}" )
          }

          PostEdit_Changelog()
          {
            Changelog_template

            while read -r
            do
              ChangelogLines+=("$REPLY")
              [[ $REPLY =~ ^[\ ]- ]] && break
            done <"${debian_changelog}"

            if [[ ${ChangelogLines[-3]} == "  * UNRELEASED" ]]
            then
              sedpattern="$(( ${#ChangelogLines[@]} - 2 )){s@  \* UNRELEASED@"
              sedterminate="@}"
            else
              sedpattern="${#ChangelogLines[@]}i"
              sedterminate='\n'
            fi

            sed -i \
            "${sedpattern}$(
                printf "\ \ %s" "${Changelog[@]}"
              )${sedterminate}" "${debian_changelog}"
          }

          [[ -e ${debian_changelog} ]] || exit 5
          LastChangelogVersion()
          {
            grep -m1 -Po "(?<=\()[^\)]+" "${debian_changelog}"
          }

          [[ ! $(LastChangelogVersion) =~ ${debVersion//[.]/[.]} ]] || exit 0

          append_changelog    &&
          gbp tag --sign-tags &&
          git push origin "${debian_branch}" "${debTAG}" || exit $?
          #TODO re-try depending on git return code

      - name: package source
        if: ${{ env.TAG != '' }}
        run: |
          set -x
          push_to_ppa()
          {
            #FIXME just an echo, it won't push to PPA
            printf 'echo dput ppa:%s "$%s"' \
                   "${PPA_ID}"         \
                   "GBP_CHANGES_FILE"
          }
          if [[ $( git tag --list "${debTAG}" ) == "${debTAG}" ]]
          then
            treeish="${debTAG}"
            tagging=()
          else
            # This is redundent, debTAG should exist
            treeish="HEAD"
            tagging=( "--git-tag" "--git-sign-tags" )
          fi

          gbp buildpackage -i'(?!debian/)'             \
            -S --no-check-builddeps                    \
            -k$( grep -m1 -Po "(?<= )[[:xdigit:]]{40}" \
                     < <( gpg --list-keys ) )          \
            --git-overlay                              \
            --git-export-dir=../build-area             \
            --git-export="${treeish}" "${tagging[@]}"  \
            --git-postbuild="$( push_to_ppa )" || exit 9

          # -i'(?!debian/)' is to ignore anything on the debian_branch
          # that is not in debian/ i.e. this yml script, and README.*
          # see dpkg-source(1)

          # -S is equivalent to --build=source, *must* use -S to avoid
          #  inconsistent behaviour of debuild and dpkg-buildpackage
          #  using long form results in debuild failing to use correct
          #  .changes file
      - name: check gpg expiry
        run: |
          set -x
          EXPIRY=$( date +%s -d \
                "$( grep -m1 -Po '(?<=expires: )[2-9][0-9]{3}(-[0-9]{2}){2}' \
                        < <( gpg --list-keys ) )" )
           TODAY="$( date +%s )"
          DAYSLEFT="$((  $(( $EXPIRY - $TODAY )) / 60/60/24 ))"
          [[ ${DAYSLEFT} -gt 60 ]] && exit 0 ||
          printf "gpg key expires in %s days\n" "${DAYSLEFT}" && exit 42
